#!/bin/bash
set -e
arg0="${0##*/}"

usage() {
    echo "NAME"
    echo
    echo "  $arg0 - install from installation staging directories"
    echo
    echo "SYNOPSIS"
    echo
    echo "  $arg0 [SWITCHES] PREFIX"
    echo
    echo "DESCRIPTION"
    echo
    echo "  This script copies parts of the build tree to the installation prefix"
    echo "  directory. This script should be invoked with the current working directory"
    echo "  set to the top of the build tree. It  recursively copies files found under the"
    echo "  install-staging directory to the same subdirectories (created if necessary)"
    echo "  under the install prefix. Any files named \"MANIFEST\" are not copied, but"
    echo "  instead contain a white-space separated list of files to copy from the build"
    echo "  directory to the installation prefix."
    echo 
    echo "  This script depends on the presense of either \"patchelf\" or \"chrpath\" in"
    echo "  order to rewrite rpath information in dynamically linked executables."
    echo
    echo "SWITCHES"
    echo
    echo "  --remove PATH | -d PATH"
    echo "      Paths to remove from rpaths. These are usually directories in the build"
    echo "      tree."
}

die() {
    echo "$arg0: $*" >&2
    exit 1
}

remove_paths=()
verbose=
while [ "$#" -gt 0 ]; do
    case "$1" in
	--)
	    shift
	    break
	    ;;
	--debug|--verbose|-v)
	    verbose=yes
	    shift
	    ;;
	--help|-h)
	    usage
	    exit 0
	    ;;
	--remove|-d)
	    [ "$#" -ge 2 ] || die "\"$1\" expects an argument"
	    remove_paths=("${remove_paths[@]}" "$1")
	    shift 2
	    ;;
	--remove=*)
	    remove_paths=("${remove_paths[@]}" "${1#--remove=}")
	    shift
	    ;;
	-d*)
	    remove_paths=("${remove_paths[@]}" "${1#-d}")
	    shift
	    ;;
	-*)
	    die "unknown command-line switch \"$1\""
	    ;;
	*)
	    break
	    ;;
    esac
done

[ "$#" -eq 1 ] || die "invalid usage"
mkdir -p "$1"
prefix=$(realpath "$1")
[ -d install-staging ] || die "no ./install-staging directory"
new_paths=("$prefix/lib")

# The program we can use to change the rpath that's embedded in a
# dynamically linked ELF executable. The patchelf tool is a bit slower
# than chrpath but can handle more cases, so we prefer it.  We don't
# report any errors here yet, but rather wait to see if we're actually
# installing any dynamically linked executables.
if [ "$rpath_changer" = "" ]; then
    if patchelf --version >/dev/null 2>&1; then
	rpath_changer=patchelf
    elif chrpath --version >/dev/null 2>&1; then
	rpath_changer=chrpath
    fi
fi

# Returns the current rpath for the given shared ELF executable.
# The return value is a colon-separated list of directory names.
current_rpath() {
    local file="$1"
    case "$rpath_changer" in
	patchelf)
	    patchelf --print-rpath "$file"
	    ;;
	chrpath)
	    chrpath --list "$file" |cut -d= -f2-
	    ;;
	skip)
	    : no path
	    ;;
	*)
	    (
		#     --------------------------------------------------------------------------------
		echo "$arg0: error: patchelf or chrpath required but not found."
		echo "   The patchelf or chrpath program is needed in order to rewrite the rpath info"
		echo "   in executables that use dynamic linking. The rpath mechanism allows the"
		echo "   executable to find shared librar for this project when that library is"
		echo "   not installed in a standard, system-wide location.  These ELF tools are often"
		echo "   available in your system package manager (e.g., Debian/Ubuntu/Mint users can"
		echo "   run \"sudo apt-get install patchelf\").  If you would rather skip the rpath"
		echo "   rewriting step and use some other method (such as LD_LIBRARY_PATH) then"
		echo "   export \"rpath_changer=skip\" when doing this install. Note that the method"
		echo "   of using LD_LIBRARY_PATH is not recommended for project's programs that"
		echo "   run non-project sub-programs because it can adversely affect the behavior of"
		echo "   the sub-program."
		echo
		echo "$arg0: instalation aborted."
	    ) >&2
	    exit 1
	    ;;
    esac
}

# Replace the rpath in the specified file with the new specified rpath.
replace_rpath() {
    local file="$1" rpath="$2"
    case "$rpath_changer" in
	patchelf)
	    patchelf --set-rpath "$rpath" "$file"
	    ;;
	chrpath)
	    # Excessivly noisy command
	    chrpath --replace "$rpath" "$file" >/dev/null
	    ;;
	skip)
	    : nothing
	    ;;
	*)
	    die "patchelf or chrpath required but not found"
	    ;;
    esac
}

if [ -n "$verbose" ]; then
    for dir in "${new_paths[@]}"; do
	echo "new_path = $dir"
    done
fi

# Was an installation prefix specified when this project was built?  If so (and we know what it is) we can change it
# in certain files we install.
if [ -r tup.config ]; then
    old_prefix="$(grep CONFIG_INSTALLATION_PREFIX tup.config |cut -d= -f2)"
fi

build_dir=$(pwd)
for manifest in $(find install-staging -name MANIFEST); do

    # Directory containing the MANIFEST file
    manifest_dir="${manifest%/MANIFEST}"

    # Which subdir of install-staging is the $manifest_dir?
    subdir="${manifest_dir#install-staging/}"

    # Destination directory is where we're going to place the file, so make sure it exists.
    destdir="$prefix/$subdir"
    mkdir -p "$destdir"

    # Process all the file names in the MANIFEST.
    for file in $(cat "$manifest"); do

	# srcfile is the path of the file to be copied.
	srcfile="$manifest_dir/$file"

	# filetgt is the base name of the destination file. We need to remove
	# any ".preinstall" extensions that might be present.
	filetgt="${srcfile##*/}"
	filetgt="${filetgt%.preinstall}"

	# dstfile is the path of the destination file
	dstfile="$destdir/$filetgt";

	# copy the file, but only if the destination doesn't exist or is older than the source.
	if [ ! -e "$dstfile" -o "$srcfile" -nt "$dstfile" ]; then
	    echo "INSTALL $dstfile"

 	    echo "ROBB: dstfile=$dstfile srcfile=$srcfile" >&2
	    case "$(basename $dstfile)" in
		rose-installed-*.cfg)
		    # If the prefix to which we're installing isn't the same as the prefix when ROSE was built, then
		    # we need to change it to the correct one.
		    if [ -n "$old_prefix" ]; then
			sed "s%${old_prefix}%${prefix}%g" <"$srcfile" >"$dstfile"
			chmod --reference="$srcfile" "$dstfile"
		    else
			cp --dereference -p "$srcfile" "$dstfile"
		    fi
		    ;;

		*.so|*.h|*.a)
		    # Copy these files as-is
		    cp --dereference -p "$srcfile" "$dstfile"
		    ;;

		*)
		    # If the file is a dynamically linked ELF executable we may need to change
		    # the rpath location for librose.so. We don't want to change the copy that's in our build
		    # tree, so we copy it first.
		    cp --dereference -p "$srcfile" "$dstfile"
		    if file "$dstfile" |grep ': ELF' |grep 'shared object' >/dev/null 2>&1; then
			old_rpath_string=$(current_rpath "$dstfile")
			old_rpath=($(echo "$old_rpath_string" |tr : ' '))

			new_rpath=()
			inserted=
			for old_dir in "${old_rpath[@]}"; do
 			    new_dir="$old_dir"
			    if $(echo "$old_dir" | egrep '^(X{96}|Y{96}|Z{96})$' >/dev/null); then
				# Remove padding paths
				new_dir=
			    elif [ "${#remove_paths[*]}" -eq 0 ]; then
				# If the user didn't specify any paths to remove, remove those that have the build directory
				# as a prefix or which don't start with a slash.
				if [ "${old_dir#$build_dir}" != "$old_dir" ]; then
				    new_dir=
				elif [ "${old_dir#/}" = "$old_dir" ]; then
				    new_dir=
				fi
			    else
				# Remove the paths that the user wants to have removed
				for user in "${remove_paths[@]}"; do
				    if [ "$old_dir" = "$user" ]; then
					new_dir=
					break
				    fi
				done
			    fi

			    if [ "$new_dir" != "" ]; then
				[ -n "$verbose" ] && echo "  $old_dir -> $new_dir" >&2
				new_rpath=("${new_rpath[@]}" "$new_dir")
			    elif [ "$inserted" = "" ]; then
				[ -n "$verbose" ] && echo "  $old_dir -> INSTALLATION_PREFIX" >&2
				new_rpath=("${new_rpath[@]}" "${new_paths[@]}")
				inserted=yes
			    else
				[ -n "$verbose" ] && echo "  $old_dir -> DELETED" >&2
			    fi
			done

			new_rpath_string="$(echo "${new_rpath[@]}" |tr ' ' :)"
			replace_rpath "$dstfile" "$new_rpath_string"
		    fi
		    ;;
	    esac
	fi
    done
done
