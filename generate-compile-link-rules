#!/usr/bin/perl

=pod

=head1 NAME

generate-compile-link-rules - tup rules for compiling and linking

=head1 SYNOPSIS

generate-compile-link-rules [I<SWITCHES>] I<INPUTS>

=head1 DESCRIPTION

This script generates Tupfile rules for the Tup build system. The purpose of the generated rules is to compile the given
source files into object files, then link them to produce an executable or library.  The output name is the base name of
the first source file unless the --output switch is specified.

=head1 INPUTS

The list of file names that serve as inputs to the command. The list should have files that end with well-known
extensions.  For example, names ending with ".C", ".cpp", and ".cxx" are C++ source files, and names ending with ".c"
are C source files.

When linking executables, if the executable depends on a library generated by this same project, the library name should
be specified as an input using the relative name of the library, like "../../libfoo.so". When linking against libraries that
are not generated in this project, use the normal linker flags like "-L/some/directory -lfoo". Note that the -L switch
should take as an argument an absolute directory name and you may want to add "-Wl,-rpath,/some/directory" as well if -lfoo
is a shared library.

=head1 SWITCHES

=over

=item --depend=I<INPUT> | --begin-deps I<INPUTS> --end-deps

Specifies order-only inputs for this rule.  The order-only inputs are those things on which the compile commands depend
but are not themselves compiled or linked. The I<INPUT> is either a quoted space separated list of dependency names or
this switch may appear more than once.  Instead of prefixing each I<INPUT> with the word "--depend", it's sometimes more
convenient to list all the I<INPUT> names between "--begin-deps" and "--end-deps" switches.

=item --extra-output=I<NAME> | -x <NAME>

Extra output that will be added to the linker command.

=item --group=I<name>

Causes the final outputs to be added to the named group.  A group name usually has a path component and a name in angle
brackets, like "../<libraries>". In order to be more easily used in shell scripts, the angle brackets may be omitted.

=item --install=I<SUBDIR>

After compiling the executable, install it in the specified subdirectory of the project's installation prefix. This
switch is parsed slightly different than others: if you provide a directory name, then it must be separated from the
switch with an equal sign, as in "--install=bin"; if you say just "--install" then an appropriate directory is chosen,
either "bin" or "lib" depending on whether the output is a program or a library.  directory; if you say "--install=none"
then the result is not installed (which is the default).

The project source tree must have a stub directory for the install point under the "install-staging" directory, such as
"\$(PROJECT_SOURCE)/install-staging/bin. This staging directory should have a Tupfile with these two lines:

=over

    include_rules
    : <staging> |> echo %<staging> >%o |> MANIFEST

=back

=item --language=I<LANGUAGE>

Overrides the language that's normally selected by the input file name extension. For instance, when the input is foo.h
file but you want it to be processed by Qt's "moc" tool to generate files named moc_foo.h and moc_foo.C, you need to
override the default language ("header") by saying "--language=moc".  Some files whose extensions are obvious are not affected
by this switch.

=item --link=(exe|lib)

Determines what kind of linking should take place. The following values are recognized:

=over

=item C<exe>

The value "exe" means that an executable is produced.

=item C<archive>

The value "archive" means an archive (*.a) file is created. These are also known as static libraries.

=item C<shared>

The value "shared" means a shared object, or dynamically linked library is created.

=item C<none>

Skip all linking steps. This produces object files (.o) from source code.

=back

If no --link flag is specified, then this script makes a choice based first on the output name, or if no output name is
specified, based on the types of inputs.

=item --macro

Emit macros instead of commands. See below for a description of what macros or commands are emitted.

=item --objects=I<BIN_NAME>

Specify a tup bin name to use for the objects generated by the compile command. The default is to choose a bin based on
the output name with "_OBJECTS" appended. The I<BIN_NAME> should not include the curly braces. Note that the compiler isn't
necessarily generating object files even though the name of this switch and its default value contain the word "object" (e.g.,
Qt has a number of source-generating translation tools including "rcc", "uic", and "moc").

=item -o I<OUTPUT> | --output=I<OUTPUT>

The name of the resulting executable or library. By default, the name of the output is computed from the name of the
first input file by removing path components and the extension, then adding an extension appropriate for the type of output.

=item --phase=I<PHASE>

This script generates rules with the assumption that a project is built in multiple phases. For instance, a large
compiler project might need to first build some tools which are then used to generate source code, which will then
be compiled to form a library, which is then linked into various programs and tests.  These three phases might be
called "support", "library" and "tool".

The phases can have any name you like, and the rules that this script generates will refer to variables and macros
whose names begin with the phase followed by an underscore (or no prefix if no phase).

=item Compiler and linker switches

The following switches are recognized and passed along to the compiler and/or linker. This list is intentionally short
in order to prevent Tupfile authors from trying to circumvent certain properties of macros and rule generators that are
needed to insure consistency across the entire build.  If you have a particular requirement, see Robb.

The recognized compiler switches are: -I, -D, and -U with one argument each.

The recognized linker switches are: -L, and -l with one argument each.

=back

=head1 MACROS AND VARIABLES

If this script emits rules containing macros, then it relies on the definitions of those macros appearing in either
the top-level Tuprules.tup file or in the Tupfiles themselves.

In the descriptions that follow, the I<PHASE> is the value of the --phase command-line switch. If this is empty, then
the following underscore is also omitted from macro and variable names.  The I<LANGUAGE> is a source language, which is
normally the lower-case string describing the language. In the case of C++, the string is "cxx".

The following macros and variables are emitted by this script:

=over

=item macro I<PHASE>_compile_I<LANGUAGE>

This macro should invoke the compiler for the specified source language and build phase. It should expect source files as
inputs from the "%f" special variable and generate object files using the "%o" special variable.  It will be given one
source file at a time.

=item macro I<PHASE>_linkexe_I<LANGUAGE>

This macro should invoke the linker for the specified source language and build phase. It should expect object files
and/or libraries as inputs in the "%f" special variable, and generate an executable output file whose name is given by
the "%o" special variable.

=item macro I<PHASE>_link_static

This macro should run commands that convert the input files, all object files in the "%f" special variable, into an
archive or static library whose name is given by the "%o" special variable.

=item macro I<PHASE>_linklib_I<LANGUAGE>

This macro should invoke a linker for the specified source language and build phase. It should expect object files
and/or archives as inputs in the "%f" special variable, and generate a shared object or dynamic library whose name is
given by the "%o" special variable.

=item variable $(ROOT)

This variable is the relative name of the top of the project's source tree relative to the directory containing this
Tupfile.

=item variable $(INSTALL_STAGING)

This variable is the relative name of the installation staging directory with respect to the top of the build tree. It
must exist as a descendent of the build tree.

=back

=head1 COMMANDS

Instead of generating rules containing macros that must be defined elsewhere, this script can also generate commands
directly. The generated commands use variables for the various parts, and those variables are similar in name to variables
found in typical Makefiles except they're prefixed with the --phase name (separated by an undercore).

=over

=item Compiler commands

Compiler commands have the form "$(CXX) $(CPPFLAGS) $(CXXFLAGS) -o %o -c %f" where substrings "CXX" are replaced by the
upper-case name of the compiler ("CXX" for the C++ compiler, "C" for the C compiler, etc.). However, the variable representing
the name of the compiler executable is an exception to the rule: $(CXX) is the C++ compiler, and the others are the language
name followed by the letter "C". The "CPPFLAGS" variable appears only for C and C++ compilers and holds command-line switches
for the C preprocessor. All of these variables are prefixed by the phase name and an underscore if a phase name was provided.

=back

=cut

use strict;
use FindBin;
use lib "$FindBin::Bin";
use TupScripts;

my($arg0) = $0 =~ m(([^/]+)$);
my $phase;   	            # prefix for all tup variables, including the trailing "_"
my $output;        	    # name of output file
my $link_mode;     	    # what kind of linking to perform
my $group;         	    # optional output group
my @compiler_args; 	    # arguments to pass to the compiler
my @linker_args;   	    # arguments to pass to the linker
my @inputs;        	    # names of the input files
my @order_inputs;  	    # additional order-only inputs
my $args_are_order_inputs;  # set by --begin-deps, cleared by --end-deps
my $install_dir = "none";   # directory in which to install, or empty to choose automatically
my $objects_bin;            # name of Tup bin for object files, excluding curly braces.
my $language;		    # override default languages
my $emit_macros;            # emit macros instead of commands
my @extra_outputs;          # extra outputs for link commands

sub parse_command_line {
    while (@_) {
	my $arg = shift @_;

	# --help
	if ($arg =~ /^(-h|--help|-\?)$/) {
	    TupScripts::help;
	    exit 0;
	}

	# --begin-deps | --end-deps
	if ($arg eq "--begin-deps") {
	    die "$arg0: invalid \"$arg\" after previous \"$arg\" with no intervening \"--end-deps\"\n" if $args_are_order_inputs;
	    $args_are_order_inputs = 1;
	    next;
	}
	if ($arg eq "--end-deps") {
	    die "$arg0: invalid \"$arg\" with no previous \"--begin-deps\"\n" unless $args_are_order_inputs;
	    $args_are_order_inputs = 0;
	    next;
	}

	# --extra-output NAME | -x NAME
	if ($arg eq '--extra-output' || $arg eq '-x') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @extra_outputs, shift @_;
	    next;
	}
	if ($arg =~ /^(--extra-output=|-d)(.*)/) {
	    push @extra_outputs, $2;
	    next;
	}

	# --group=NAME
	if ($arg eq "--group") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $group = shift @_;
	    next;
	}
	if ($arg =~ /^--group=(.*)/) {
	    $group = $1;
	    next;
	}

	# --depend=NAME
	if ($arg eq '--depend') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @order_inputs, shift @_;
	    next;
	}
	if ($arg =~ /^--depend=(.*)/) {
	    push @order_inputs, $1;
	    next;
	}

	# --install
	if ($arg eq '--install') {
	    $install_dir = "";  # choose directory later
	    next;
	}
	if ($arg =~ /^--install=(.*)/) {
	    $install_dir = $1;
	    next;
	}

	# --language=LANG
	if ($arg eq '--language') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $language = shift @_;
	    next;
	}
	if ($arg =~ /^--language=(.*)/) {
	    $language = $1;
	    next;
	}

	# --link=MODE
	if ($arg eq '--link') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $link_mode = shift @_;
	    next;
	}
	if ($arg =~ /^--link=(.*)/) {
	    $link_mode = $1;
	    next;
	}

	# --macro
	if ($arg eq '--macro') {
	    $emit_macros = 1;
	    next;
	}
	if ($arg eq '--no-macro') {
	    $emit_macros = 0;
	    next;
	}
	       
	# -o NAME | --output=NAME
	if ($arg =~ /^(-o|--output)$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $output = shift @_;
	    next;
	}
	if ($arg =~ /^(-o|--output=)(.*)/) {
	    $output = $2;
	    next;
	}

	# --objects=BIN
	if ($arg eq "--objects") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $objects_bin = shift @_;
	    next;
	}
	if ($arg =~ /^--objects=(.*)/) {
	    $objects_bin = $1;
	    next;
	}

	# --phase=NAME
	if ($arg eq "--phase") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $phase = shift @_;
	    next;
	}
	if ($arg =~ /^--phase=(.*)/) {
	    $phase = $1;
	    next;
	}

	# Switches passed to the compiler
	if ($arg =~ /^-[DIU]$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @compiler_args, $arg, shift @_;
	    next;
	}
	if ($arg =~ /^-[DIU](.*)/) {
	    push @compiler_args, $arg;
	    next;
	}

	# Switches passed to the linker
	if ($arg =~ /^-[Ll]$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @linker_args, $arg, shift @_;
	    next;
	}
	if ($arg =~ /^-[Ll](.*)/) {
	    push @linker_args, $arg;
	    next;
	}

	# Unknown
	if ($arg =~ /^-/) {
	    die "$arg0: unknown switch: $arg\n";
	}

	# Input file
	if ($args_are_order_inputs) {
	    push @order_inputs, $arg;
	} else {
	    push @inputs, $arg;
	}
    }

    die "$arg0: missing \"--end-deps\" switch\n" if $args_are_order_inputs;
    die "$arg0: no inputs specified\n" unless @inputs;
    $install_dir = "auto" if $install_dir eq "";
    $phase .= "_" unless $phase eq "";
    die "$arg0: --group and --install are mutually exclusive\n" if $group && $install_dir ne "none";
    die "$arg0: object bin \"$objects_bin\" (from --objects) is malformed\n" unless $objects_bin =~ /^\w*$/;
}

# Given a list of languages (c, cxx) return the language that should be used for linking.
sub linker_language {
    return "d" if grep {$_ eq "d"} @_;
    return "cxx" if grep {$_ eq "c++"} @_;
    return $language || "c";
}

# Fix the a group specification by adding angle brackets around the last component of the path.
sub make_group_name {
    my($input) = @_;
    return "" unless $input;
    my @parts = split "/", $input;
    $parts[-1] = "<" . $parts[-1] . ">" unless $parts[-1] =~ /^<.*>$/;
    return join "/", @parts;
}

########################################################################################################################

parse_command_line @ARGV;
$group = make_group_name $group;

# If any header files are specified in the inputs, move them to the order-only inputs instead because headers are not
# normally compiled directly.
if ($language ne "moc") {
    push @order_inputs, grep {TupScripts::language("", $_) eq "header"} @inputs;
    @inputs =           grep {TupScripts::language("", $_) ne "header"} @inputs;
}

# If no link mode was specified, try to guess based on output name and/or input names.
if ($link_mode eq "") {
    if ($output =~ /\.a$/) {
	$link_mode = "archive";
    } elsif ($output =~ /\.so$/) {
	$link_mode = "shared";
    } elsif ($language eq "moc" || grep {TupScripts::is_qt_ui($_) || TupScripts::is_qt_resource($_)} @inputs) {
	$link_mode = "none";
    } else {
	$link_mode = "exe";
    }
}

# Check that the link mode is consistent with the output and input names. Also choose an output name if none was given.
if ($link_mode eq "exe") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_library($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating an executable is not source code, object, or library: $input\n";
	}
    }
    if ($output eq "") {
	my @non_libs = grep {!TupScripts::is_library($_)} @inputs;
	my $best_input = @non_libs ? $non_libs[0] : $inputs[0];
	$output = TupScripts::make_variable($best_input);
    }
    $install_dir = "bin" if $install_dir eq "auto";

} elsif ($link_mode eq "archive") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating an archive (static library) is not source code or object: $input\n";
	}
    }
    if ($output eq "") {
	$output = "lib" . TupScripts::make_variable($inputs[0]) . ".a";
    } else {
	$output .= ".a"	unless $output =~ /\.a$/;
	$output = "lib" . $output unless $output =~ /^lib/;
    }
    $install_dir = "lib" if $install_dir eq "auto";

} elsif ($link_mode eq "shared") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating a shared object (dynamic library) is not source code or object: $input\n";
	}
    }
    if ($output eq "") {
	$output = "lib" . TupScripts::make_variable($inputs[0]) . ".so";
    } else {
	$output .= ".so" unless $output =~ /\.so$/;
	$output = "lib" . $output unless $output =~ /^lib/;
    }
    $install_dir = "lib" if $install_dir eq "auto";

} elsif ($link_mode eq "none") {
    my($generatingObjects, $generatingSource);
    for my $input (@inputs) {
	if (TupScripts::is_source_code($input)) {
	    # okay, we're compiling source code to generate object files
	    $generatingObjects = 1;
	} elsif (TupScripts::is_qt_ui($input)) {
	    # okay, we're running Qt's "uic" tool to generate more *.h files
	    $generatingSource = 1;
	} elsif (TupScripts::is_qt_resource($input)) {
	    # okay, we're running Qt's "rcc" tool to generate more *.C files
	    $generatingSource = 1;
	} else {
	    die "$arg0: unrecognized compiler input file: $input\n";
	}
    }
    if ($generatingObjects && $output) {
	die "$arg0: --output is prohibited when generating object files\n";
    } elsif ($generatingSource && $output) {
	die "$arg0: --output is prohibited when generating source files\n";
    }
    $output = TupScripts::make_variable($inputs[0]); # but we still need $output for various other things
} else {
    die "$arg0: invalid --link mode: $link_mode\n";
}

my($var) = TupScripts::make_variable($output);
$objects_bin = "${var}_OBJECTS" unless $objects_bin;

# Split the inputs into arrays based on their type.
my %sources = TupScripts::by_language($language, @inputs);

# Generate the compile rules
my $ncompiled = 0;
for my $lang (keys %sources) {
    next unless @{$sources{$lang}};
    my $compile_macro = "${phase}compile_${lang}";       # name of macro if we're emitting macros
    my @rule_outputs;                                    # output names for the rule like %B.o, etc.
    my $uc_lang = uc($lang);                             # upper-case language name like CXX, C, D, etc. overridden below
    my $uc_compiler = TupScripts::compiler_exe($lang);   # upper-case compiler name like CXX, CC, etc.
    my @extra_compiler_args;                             # switches, flags, etc. appearing at end of command

    if ($lang eq "c++" || $lang eq "c") {
	$uc_lang = "CXX" if $uc_lang eq "C++";
	$compile_macro = "${phase}compile_" . lc($uc_compiler);
	push @rule_outputs, "${output}-%B.o";
	push @extra_compiler_args, '-o', '%o', '-c', '%f';
    } elsif ($lang eq 'd') {
	push @rule_outputs, TupScripts::make_variable($output) . '-%B.o';
	push @extra_compiler_args, '-of=%o', '-c', '%f';
    } elsif ($lang eq "moc") {
	push @rule_outputs, "moc_%B.cpp";
	push @extra_compiler_args, '-o', '%o', '%f';
    } elsif (TupScripts::is_source_code($sources{$lang}[0])) {
	push @rule_outputs, "${output}-%B.o";
	push @extra_compiler_args, '-o', '%o', '%f';
    } elsif (TupScripts::is_qt_ui($sources{$lang}[0])) {
	$uc_lang = "UIC";
	push @rule_outputs, "ui_%B.h";
	push @extra_compiler_args, '-o', '%o', '%f';
    } elsif (TupScripts::is_qt_resource($sources{$lang}[0])) {
	$uc_lang = "RCC";
	push @rule_outputs, "qrc_%B.C";
	push @extra_compiler_args, '-o', '%o', '%f';
    } else {
	next; # not something to be compiled
    }

    # Inputs
    print ": foreach ", join(" ", @{$sources{$lang}});
    print " | ", join(" ", TupScripts::fix_bins(@order_inputs)) if @order_inputs;

    # Macro or command
    print " |>";
    if ($emit_macros) {
	print " !${compile_macro}";
	print " ", TupScripts::shell_escape($_) for @compiler_args;
    } else {
	print " ^c ${phase}${uc_compiler} \%f^";
	print " \$(${phase}${uc_compiler})";
	print " \$(${phase}CPPFLAGS)" if $lang eq "c++" || $lang eq "c";
	print " \$(${phase}${uc_lang}FLAGS)";
	print " ", TupScripts::shell_escape($_) for @compiler_args;
	print " ", join(" ", @extra_compiler_args) if @extra_compiler_args;
    }

    # Outputs
    print " |> ", join(" ", @rule_outputs);
    print " ${group}" if $group && $link_mode eq "none";
    print " {${objects_bin}}\n";

    $ncompiled += @{$sources{$lang}};
}

# Generate the link rule
if ($link_mode ne "none") {
    my $lang = linker_language(keys %sources);

    # Get the list of linker inputs
    my @linker_inputs;
    push @linker_inputs, "{${objects_bin}}" if $ncompiled > 0;
    push @linker_inputs, TupScripts::fix_groups_bins(@{$sources{object}});

    # Get the various parts of the eventual macro or command
    my $link_macro;
    my @compiler_args;
    if ($link_mode eq "exe") {
	$link_macro = "${phase}linkexe_" . linker_language(keys %sources);
	if ($lang eq 'd') {
	    push @compiler_args, '-of=%o', TupScripts::tup_input_variable(@linker_inputs);
	} else {
	    push @compiler_args, '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
	}
    } elsif ($link_mode eq "archive") {
	$link_macro = "${phase}link_static";
    } elsif ($link_mode eq "shared") {
	$link_macro = "${phase}linklib_" . linker_language(keys %sources);
	if ($lang eq 'cxx' || $lang eq 'c') {
	    push @compiler_args, '-shared', '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
	} elsif ($lang eq 'd') {
	    push @compiler_args, '-lib', '-of=%o', TupScripts::tup_input_variable(@linker_inputs);
	} else {
	    push @compiler_args, '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
	}
    } else {
	die "$arg0: internal logic error\n";
    }

    # Library names specified as files, like "../../libfoo.so" need to be passed to the linker as "-L../.. -lfoo" in order
    # to work properly with rpath after being installed, but they need to be listed as "../../libfoo.so" in the rule's
    # order-only dependencies so that Tup knows about them. Furthermore, the directory names should be absolute so that
    # the resulting executable can be invoked from any working directory.
    my @linker_order_inputs;
    for my $lib (@{$sources{library}}) {
	my $lib_basename = TupScripts::base_name($lib);
	my($lib_dirname) = TupScripts::absolute_name(TupScripts::directory_name($lib));
	my($lib_name) = $lib_basename =~ /^lib(.*)\.(so|a)$/;

	push @linker_order_inputs, $lib unless $lib =~ /^\//; # absolute names are not managed by Tup
	if ($lang eq 'cxx' || $lang eq 'c') {
	    unshift @linker_args, "-L$lib_dirname", "-Wl,-rpath,$lib_dirname", "-l$lib_name";
	} elsif ($lang eq 'd') {
	    unshift @linker_args, $lib, "-L=-rpath", "-L=$lib_dirname";
	} else {
	    unshift @linker_args, $lib;
	}
    }

    # Rule inputs
    print ": ", join(" ", @linker_inputs);
    print " | ", join(" ", @linker_order_inputs) if @linker_order_inputs;

    # The command or macro
    print " |>";
    if ($emit_macros) {
	print " !${link_macro}";
	print " ", join(" ", @linker_args) if @linker_args;
    } elsif ($link_mode eq "archive") {
	print " ^c ${phase}LINK \%o^ ar rcs %o %f";
    } else {
	my $uc_lang = uc($lang);
	my $uc_compiler = TupScripts::compiler_exe($lang);
	print " ^c ${phase}LINK \%o^";
	print " \$(${phase}${uc_compiler}) \$(${phase}${uc_lang}FLAGS)";
	print " ", join(" ", @compiler_args) if @compiler_args;
	print " ", join(" ", @linker_args) if @linker_args;
	print " \$(${phase}LDFLAGS)";
    }

    # Output
    print " |> ${output}";
    print " | ", join(" ", @extra_outputs) if @extra_outputs;
    print " ${group}" if $group;
    print " \$(ROOT)/\$(INSTALL_STAGING)/$install_dir/<staging>" if $install_dir ne "none";
    print "\n";
}
