#!/usr/bin/perl

=pod

=head1 NAME

generate-compile-link-rules - tup rules for compiling and linking

=head1 SYNOPSIS

generate-compile-link-rules [I<SWITCHES>] I<INPUTS>

=head1 DESCRIPTION

This script generates Tupfile rules for the Tup build system. The purpose of the generated rules is to compile the given
source files into object files, then link them to produce an executable or library.  The output name is the base name of
the first source file unless the --output switch is specified.

=head1 INPUTS

The list of file names that serve as inputs to the command. The list should have files that end with well-known
extensions.  For example, names ending with ".C", ".cpp", and ".cxx" are C++ source files, and names ending with ".c"
are C source files.

When linking executables, if the executable depends on a library generated by this same project, the library name should
be specified as an input using the relative name of the library, like "../../libfoo.so". When linking against libraries that
are not generated in this project, use the normal linker flags like "-L/some/directory -lfoo". Note that the -L switch
should take as an argument an absolute directory name and you may want to add "-Wl,-rpath,/some/directory" as well if -lfoo
is a shared library.

=head1 SWITCHES

=over

=item --group=I<name>

Causes the final outputs to be added to the named group.  A group name usually has a path component and a name in angle
brackets, like "../<libraries>". In order to be more easily used in shell scripts, the angle brackets may be omitted.

=item -i I<INPUT> | --input=I<INPUT>

Specifies order-only inputs for this rule.  The order-only inputs are those things on which the compile commands depend
but are not themselves compiled or linked. The I<INPUT> is either a quoted space separated list of dependency names or
this switch may appear more than once.

=item --install=I<SUBDIR>

After compiling the executable, install it in the specified subdirectory of the project's installation prefix. This
switch is parsed slightly different than others: if you provide a directory name, then it must be separated from the
switch with an equal sign, as in "--install=bin"; if you say just "--install" then an appropriate directory is chosen,
either "bin" or "lib" depending on whether the output is a program or a library.  directory; if you say "--install=none"
then the result is not installed (which is the default).

The project source tree must have a stub directory for the install point under the "install-staging" directory, such as
"\$(PROJECT_SOURCE)/install-staging/bin. This staging directory should have a Tupfile with these two lines:

=over

    include_rules
    : <staging> |> echo %<staging> >%o |> MANIFEST

=back

=item --language=I<LANGUAGE>

Overrides the language that's normally selected by the input file name extension. For instance, when the input is foo.h
file but you want it to be processed by Qt's "moc" tool to generate files named moc_foo.h and moc_foo.C, you need to
override the default language ("header") by saying "--language=moc".

=item --link=(exe|lib)

Determines what kind of linking should take place. The following values are recognized:

=over

=item C<exe>

The value "exe" means that an executable is produced.

=item C<archive>

The value "archive" means an archive (*.a) file is created. These are also known as static libraries.

=item C<shared>

The value "shared" means a shared object, or dynamically linked library is created.

=item C<none>

Skip all linking steps. This produces object files (.o) from source code.

=back

If no --link flag is specified, then this script makes a choice based first on the output name, or if no output name is
specified, based on the types of inputs.

=item --objects=I<BIN_NAME>

Specify a tup bin name to use for the objects generated by the compile command. The default is to choose a bin based on
the output name with "_OBJECTS" appended. The I<BIN_NAME> should not include the curly braces. Note that the compiler isn't
necessarily generating object files even though the name of this switch and its default value contain the word "object" (e.g.,
Qt has a number of source-generating translation tools including "rcc", "uic", and "moc").

=item -o I<OUTPUT> | --output=I<OUTPUT>

The name of the resulting executable or library. By default, the name of the output is computed from the name of the
first input file by removing path components and the extension, then adding an extension appropriate for the type of output.

=item --phase=I<PHASE>

This script generates rules with the assumption that a project is built in multiple phases. For instance, a large
compiler project might need to first build some tools which are then used to generate source code, which will then
be compiled to form a library, which is then linked into various programs and tests.  These three phases might be
called "support", "library" and "tool".

The phases can have any name you like, and the rules that this script generates will refer to variables and macros
whose names begin with the phase followed by an underscore (or no prefix if no phase).

=item Compiler and linker switches

The following switches are recognized and passed along to the compiler and/or linker. This list is intentionally short
in order to prevent Tupfile authors from trying to circumvent certain properties of macros and rule generators that are
needed to insure consistency across the entire build.  If you have a particular requirement, see Robb.

The recognized compiler switches are: -I, -D, and -U with one argument each.

The recognized linker switches are: -L, and -l with one argument each.

=back

=head1 MACROS AND VARIABLES

This script emits rules containing macros and relies on the Tuprules.tup file of the project to provide appropriate
definitions for those macros.

In the descriptions that follow, the I<PHASE> is the value of the --phase command-line switch. If this is empty, then
the following underscore is also omitted from macro and variable names.  The I<LANGUAGE> is a source language, which is
normally the lower-case string describing the language. In the case of C++, the string is "cxx".

The following macros and variables are emitted by this script:

=over

=item macro I<PHASE>_compile_I<LANGUAGE>

This macro should invoke the compiler for the specified source language and build phase. It should expect source files as
inputs from the "%f" special variable and generate object files using the "%o" special variable.  It will be given one
source file at a time.

=item macro I<PHASE>_linkexe_I<LANGUAGE>

This macro should invoke the linker for the specified source language and build phase. It should expect object files
and/or libraries as inputs in the "%f" special variable, and generate an executable output file whose name is given by
the "%o" special variable.

=item macro I<PHASE>_link_static

This macro should run commands that convert the input files, all object files in the "%f" special variable, into an
archive or static library whose name is given by the "%o" special variable.

=item macro I<PHASE>_linklib_I<LANGUAGE>

This macro should invoke a linker for the specified source language and build phase. It should expect object files
and/or archives as inputs in the "%f" special variable, and generate a shared object or dynamic library whose name is
given by the "%o" special variable.

=item variable $(ROOT)

This variable is the relative name of the top of the project's source tree relative to the directory containing this
Tupfile.

=item variable $(INSTALL_STAGING)

This variable is the relative name of the installation staging directory with respect to the top of the build tree. It
must exist as a descendent of the build tree.

=back

=cut

use strict;
use FindBin;
use lib "$FindBin::Bin";
use TupScripts;

my($arg0) = $0 =~ m(([^/]+)$);
my $phase;   	            # prefix for all tup variables, including the trailing "_"
my $output;        	    # name of output file
my $link_mode;     	    # what kind of linking to perform
my $group;         	    # optional output group
my @compiler_args; 	    # arguments to pass to the compiler
my @linker_args;   	    # arguments to pass to the linker
my @inputs;        	    # names of the input files
my @order_inputs;  	    # additional order-only inputs
my $install_dir = "none";   # directory in which to install, or empty to choose automatically
my $objects_bin;            # name of Tup bin for object files, excluding curly braces.
my $language;		    # override default languages

sub parse_command_line {
    while (@_) {
	my $arg = shift @_;

	# --help
	if ($arg =~ /^(-h|--help|-\?)$/) {
	    TupScripts::help;
	    exit 0;
	}

	# --group=NAME
	if ($arg eq "--group") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $group = shift @_;
	    next;
	}
	if ($arg =~ /^--group=(.*)/) {
	    $group = $1;
	    next;
	}

	# -i NAME | --input=NAME
	if ($arg =~ /^(-i|--inputs?)$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @order_inputs, shift @_;
	    next;
	}
	if ($arg =~ /^(-i|--inputs?=)(.*)/) {
	    push @order_inputs, $2;
	    next;
	}

	# --install
	if ($arg eq '--install') {
	    $install_dir = "";  # choose directory later
	    next;
	}
	if ($arg =~ /^--install=(.*)/) {
	    $install_dir = $1;
	    next;
	}

	# --language=LANG
	if ($arg eq '--language') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $language = shift @_;
	    next;
	}
	if ($arg =~ /^--language=(.*)/) {
	    $language = $1;
	    next;
	}

	# --link=MODE
	if ($arg eq '--link') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $link_mode = shift @_;
	    next;
	}
	if ($arg =~ /^--link=(.*)/) {
	    $link_mode = $1;
	    next;
	}
	       
	# -o NAME | --output=NAME
	if ($arg =~ /^(-o|--output)$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $output = shift @_;
	    next;
	}
	if ($arg =~ /^(-o|--output=)(.*)/) {
	    $output = $2;
	    next;
	}

	# --objects=BIN
	if ($arg eq "--objects") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $objects_bin = shift @_;
	    next;
	}
	if ($arg =~ /^--objects=(.*)/) {
	    $objects_bin = $1;
	    next;
	}

	# --phase=NAME
	if ($arg eq "--phase") {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $phase = shift @_;
	    next;
	}
	if ($arg =~ /^--phase=(.*)/) {
	    $phase = $1;
	    next;
	}

	# Switches passed to the compiler
	if ($arg =~ /^-[DIU]$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @compiler_args, $arg, shift @_;
	    next;
	}
	if ($arg =~ /^-[DIU](.*)/) {
	    push @compiler_args, $arg;
	    next;
	}

	# Switches passed to the linker
	if ($arg =~ /^-[Ll]$/) {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    push @linker_args, $arg, shift @_;
	    next;
	}
	if ($arg =~ /^-[Ll](.*)/) {
	    push @linker_args, $arg;
	    next;
	}

	# Unknown
	if ($arg =~ /^-/) {
	    die "$arg0: unknown switch: $arg\n";
	}

	# Input file
	push @inputs, $arg;
    }

    die "$arg0: no inputs specified\n" unless @inputs;
    $install_dir = "auto" if $install_dir eq "";
    $phase .= "_" unless $phase eq "";
    die "$arg0: --group and --install are mutually exclusive\n" if $group && $install_dir ne "none";
    die "$arg0: object bin \"$objects_bin\" (from --objects) is malformed\n" unless $objects_bin =~ /^\w*$/;
}

# Create a Tup variable name by replacing special characters with underscores.
sub varname {
    local($_) = @_;
    s/\W/_/g;
    return $_;
}


# Given a list of languages (c, cxx) return the language that should be used for linking.
sub linker_language {
    return "d" if grep {$_ eq "d"} @_;
    return "cxx" if grep {$_ eq "c++"} @_;
    return "c";
}

# Fix the a group specification by adding angle brackets around the last component of the path.
sub fix_group_name {
    my($input) = @_;
    return "" unless $input;
    my @parts = split "/", $input;
    $parts[-1] = "<" . $parts[-1] . ">" unless $parts[-1] =~ /^<.*>$/;
    return join "/", @parts;
}

########################################################################################################################

parse_command_line @ARGV;
$group = fix_group_name $group;

# If any header files are specified in the inputs, move them to the order-only inputs instead because headers are not
# normally compiled directly.
if ($language ne "moc") {
    push @order_inputs, grep {TupScripts::language($_) eq "header"} @inputs;
    @inputs =           grep {TupScripts::language($_) ne "header"} @inputs;
}

# If no link mode was specified, try to guess based on output name and/or input names.
if ($link_mode eq "") {
    if ($output =~ /\.a$/) {
	$link_mode = "archive";
    } elsif ($output =~ /\.so$/) {
	$link_mode = "shared";
    } elsif ($language eq "moc" || grep {TupScripts::is_qt_ui($_) || TupScripts::is_qt_resource($_)} @inputs) {
	$link_mode = "none";
    } else {
	$link_mode = "exe";
    }
}

# Check that the link mode is consistent with the output and input names. Also choose an output name if none was given.
if ($link_mode eq "exe") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_library($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating an executable is not source code, object, or library: $input\n";
	}
    }
    $output = TupScripts::base_name_no_ext($inputs[0]) if $output eq "";
    $install_dir = "bin" if $install_dir eq "auto";

} elsif ($link_mode eq "archive") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating an archive (static library) is not source code or object: $input\n";
	}
    }
    if ($output eq "") {
	$output = "lib" . TupScripts::base_name_no_ext($inputs[0]) . ".a";
    } else {
	$output .= ".a"	unless $output =~ /\.a$/;
	$output = "lib" . $output unless $output =~ /^lib/;
    }
    $install_dir = "lib" if $install_dir eq "auto";

} elsif ($link_mode eq "shared") {
    for my $input (@inputs) {
	if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input)) {
	    die "$arg0: input for generating a shared object (dynamic library) is not source code or object: $input\n";
	}
    }
    if ($output eq "") {
	$output = "lib" . TupScripts::base_name_no_ext($inputs[0]) . ".so";
    } else {
	$output .= ".so" unless $output =~ /\.so$/;
	$output = "lib" . $output unless $output =~ /^lib/;
    }
    $install_dir = "lib" if $install_dir eq "auto";

} elsif ($link_mode eq "none") {
    my($generatingObjects, $generatingSource);
    for my $input (@inputs) {
	if (TupScripts::is_source_code($input)) {
	    # okay, we're compiling source code to generate object files
	    $generatingObjects = 1;
	} elsif (TupScripts::is_qt_ui($input)) {
	    # okay, we're running Qt's "uic" tool to generate more *.h files
	    $generatingSource = 1;
	} elsif (TupScripts::is_qt_resource($input)) {
	    # okay, we're running Qt's "rcc" tool to generate more *.C files
	    $generatingSource = 1;
	} else {
	    die "$arg0: unrecognized compiler input file: $input\n";
	}
    }
    if ($generatingObjects && $output) {
	die "$arg0: --output is prohibited when generating object files\n";
    } elsif ($generatingSource && $output) {
	die "$arg0: --output is prohibited when generating source files\n";
    }
    $output = TupScripts::base_name_no_ext($inputs[0]); # but we still need $output for various other things
} else {
    die "$arg0: invalid --link mode: $link_mode\n";
}

my($var) = varname($output);
$objects_bin = "${var}_OBJECTS" unless $objects_bin;

# Generate the compile rules
my %sources;
if ($language) {
    $sources{$language} = \@inputs;
} else {
    %sources = TupScripts::by_language(@inputs);
}
my $ncompiled = 0;
for my $lang (keys %sources) {
    # Macro name for compiling
    my $compile_macro;
    my @rule_outputs;
    if ($lang eq "c++") {
	$compile_macro = "${phase}compile_cxx";
	push @rule_outputs, "${output}-%B.o";
    } elsif ($lang eq "moc") {
	$compile_macro = "${phase}compile_moc";
	push @rule_outputs, "moc_%B.cpp";
    } elsif (TupScripts::is_source_code($sources{$lang}[0])) {
	$compile_macro = "${phase}compile_${lang}";
	push @rule_outputs, "${output}-%B.o";
    } elsif (TupScripts::is_qt_ui($sources{$lang}[0])) {
	$compile_macro = "${phase}compile_${lang}";
	push @rule_outputs, "ui_%B.h";
    } elsif (TupScripts::is_qt_resource($sources{$lang}[0])) {
	$compile_macro = "${phase}compile_${lang}";
	push @rule_outputs, "qrc_%B.C";
    } else {
	next; # not something to be compiled
    }

    print ": foreach ", join(" ", @{$sources{$lang}});
    print " | ", join(" ", TupScripts::fix_bin(@order_inputs)) if @order_inputs;
    print " |> !${compile_macro}";
    for my $arg (@compiler_args) {
	print " ", TupScripts::shell_escape($arg);
    }
    print " |> ", join(" ", @rule_outputs);
    print " ${group}" if $group && $link_mode eq "none";
    print " {${objects_bin}}\n";
    $ncompiled += @{$sources{$lang}};
}

# Generate the link rule
if ($link_mode ne "none") {
    my $link_macro;
    if ($link_mode eq "exe") {
	$link_macro = "${phase}linkexe_" . linker_language(keys %sources);
    } elsif ($link_mode eq "archive") {
	$link_macro = "${phase}link_static";
    } elsif ($link_mode eq "shared") {
	$link_macro = "${phase}linklib_" . linker_language(keys %sources);
    } else {
	die "$arg0: internal logic error\n";
    }
    
    print ":";
    print " {${objects_bin}}" if $ncompiled > 0;
    print " ", join(" ", @{$sources{object}}) if $sources{object};

    # Library names specified as files, like "../../libfoo.so" need to be passed to the linker as "-L../.. -lfoo" in order
    # to work properly with rpath after being installed, but they need to be listed as "../../libfoo.so" in the rule's
    # order-only dependencies so that Tup knows about them.
    my @linker_order_inputs;
    for my $lib (@{$sources{library}}) {
	my $lib_basename = TupScripts::base_name($lib);
	my($lib_dirname) = TupScripts::directory_name($lib);
	my($lib_name) = $lib_basename =~ /^lib(.*)\.(so|a)$/;

	push @linker_order_inputs, $lib;
	push @linker_args, "-L$lib_dirname", "-l$lib_name";
    }
    print " | ", join(" ", @linker_order_inputs) if @linker_order_inputs;

    print " |> !${link_macro}";
    print " ", join(" ", @linker_args) if @linker_args;
    print " |> ${output}";
    print " ${group}" if $group;
    print " \$(ROOT)/\$(INSTALL_STAGING)/$install_dir/<staging>" if $install_dir ne "none";
    print "\n";
}
