#!/usr/bin/perl

=pod

=head1 NAME

generate-compile-link-rules - tup rules for compiling and linking

=head1 SYNOPSIS

generate-compile-link-rules [I<SWITCHES>] I<INPUTS>

=head1 DESCRIPTION

This script generates Tupfile rules for the Tup build system. The purpose of the generated rules is to compile the given
source files into object files, then link them to produce an executable or library.  The output name is the base name of
the first source file unless the --output switch is specified.

=head1 INPUTS

The list of file names that serve as inputs to the command. The list should have files that end with well-known
extensions.  For example, names ending with ".C", ".cpp", and ".cxx" are C++ source files, and names ending with ".c"
are C source files.

When linking executables, if the executable depends on a library generated by this same project, the library name should
be specified as an input using the relative name of the library, like "../../libfoo.so". When linking against libraries that
are not generated in this project, use the normal linker flags like "-L/some/directory -lfoo". Note that the -L switch
should take as an argument an absolute directory name and you may want to add "-Wl,-rpath,/some/directory" as well if -lfoo
is a shared library.

=head1 SWITCHES

=over

=item --compilation-database=I<GROUP>

Emit rules that will generate JSON files containing information about the command that would be run to compile a file.
The specification can be found in the LLVM "JSON Compilation Database Format Specification" document. The I<GROUP> is
the name of the Tup group for the JSON files, which will ultimately be used to merge all such JSON files into a single
database.

=item --depend=I<INPUT> | --begin-deps I<INPUTS> --end-deps

Specifies order-only inputs for this rule.  The order-only inputs are those things on which the compile commands depend
but are not themselves compiled or linked. The I<INPUT> is either a quoted space separated list of dependency names or
this switch may appear more than once.  Instead of prefixing each I<INPUT> with the word "--depend", it's sometimes more
convenient to list all the I<INPUT> names between "--begin-deps" and "--end-deps" switches.

=item --extra-output=I<NAME> | -x <NAME>

Extra output that will be added to the linker command.

=item --group=I<name>

Causes the final outputs to be added to the named group.  A group name usually has a path component and a name in angle
brackets, like "../<libraries>". In order to be more easily used in shell scripts, the angle brackets may be omitted.

=item --install=I<SUBDIR>

After compiling the executable, install it in the specified subdirectory of the project's installation prefix. This
switch is parsed slightly different than others: if you provide a directory name, then it must be separated from the
switch with an equal sign, as in "--install=bin"; if you say just "--install" then an appropriate directory is chosen,
either "bin" or "lib" depending on whether the output is a program or a library.  directory; if you say "--install=none"
then the result is not installed (which is the default).

The project source tree must have a stub directory for the install point under the "install-staging" directory, such as
"\$(PROJECT_SOURCE)/install-staging/bin. This staging directory should have a Tupfile with these two lines:

=over

    include_rules
    : <staging> |> echo %<staging> >%o |> MANIFEST

=back

=item --language=I<LANGUAGE>

Overrides the language that's normally selected by the input file name extension. For instance, when the input is foo.h
file but you want it to be processed by Qt's "moc" tool to generate files named moc_foo.h and moc_foo.C, you need to
override the default language ("header") by saying "--language=moc".  Some files whose extensions are obvious are not affected
by this switch.

=item --linkage=(shared|static|both)

Determines how the output object is linked.

=over

=item C<shared>

When creating a library, create a shared object for dynamic linking. When creating an executable, create an executable
that links to shared libraries.

=item C<static>

When creating a library, create a non-shared library (e.g., Unix object archive, lib*.a). When creating an executable,
use static linking so the executable contains the library's contents.

=item C<both>

When creating a library, create both shared and static versions. When creating an executable, create two versions: an
executable that uses dynamic linking, and another one that uses static linking. The statically linked executable is
given a different name, perhaps by appending ".static".

=back

=item --link=(exe|lib)

Determines what kind of linking should take place. The following values are recognized:

=over

=item C<exe>

Produce an executable.  The executable is statically and/or dynamically linked according to the --link flag.

=item C<lib>

Produce a library. This produces a shared and/or static library depending on the --link flag.

=item C<none>

Skip all linking steps. This produces object files (.o) from source code.

=back

If no --link flag is specified, then this script makes a choice based first on the output name, or if no output name is
specified, based on the types of inputs.

=item --macro

Emit macros instead of commands. See below for a description of what macros or commands are emitted.

=item --map=I<SOURCE_DIR>,I<ROOT>

Defines how tup maps the root of the source code hierarchy onto the root of the build hierarchy. The I<SOURCE_DIR> is
the absolute name of the root of the source code (i.e., where Tupfile.ini would be if it were present), and I<ROOT> is
the relative path from the current working directory to the root of the build tree (where tup.config would be for the
variant that's being built, i.e., tup's $(TUP_CWD) variable).

=item --objects=I<BIN_NAME>

Specify a tup bin name to use for the objects generated by the compile command. The default is to choose a bin based on
the output name with "_OBJECTS" appended. The I<BIN_NAME> should not include the curly braces. Note that the compiler isn't
necessarily generating object files even though the name of this switch and its default value contain the word "object" (e.g.,
Qt has a number of source-generating translation tools including "rcc", "uic", and "moc").

=item -o I<OUTPUT> | --output=I<OUTPUT>

The name of the resulting executable or library. By default, the name of the output is computed from the name of the
first input file by removing path components and the extension, then adding an extension appropriate for the type of output.

=item --phase=I<PHASE>

This script generates rules with the assumption that a project is built in multiple phases. For instance, a large
compiler project might need to first build some tools which are then used to generate source code, which will then
be compiled to form a library, which is then linked into various programs and tests.  These three phases might be
called "support", "library" and "tool".

The phases can have any name you like, and the rules that this script generates will refer to variables and macros
whose names begin with the phase followed by an underscore (or no prefix if no phase).

=item Compiler and linker switches

The following switches are recognized and passed along to the compiler and/or linker. This list is intentionally short
in order to prevent Tupfile authors from trying to circumvent certain properties of macros and rule generators that are
needed to insure consistency across the entire build.  If you have a particular requirement, see Robb.

The recognized compiler switches are: -I, -D, and -U with one argument each.

The recognized linker switches are: -L, and -l with one argument each.

=back

=head1 MACROS AND VARIABLES

If this script emits rules containing macros, then it relies on the definitions of those macros appearing in either
the top-level Tuprules.tup file or in the Tupfiles themselves.

In the descriptions that follow, the I<PHASE> is the value of the --phase command-line switch. If this is empty, then
the following underscore is also omitted from macro and variable names.  The I<LANGUAGE> is a source language, which is
normally the lower-case string describing the language. In the case of C++, the string is "cxx".

The following macros and variables are emitted by this script:

=over

=item macro I<PHASE>_compile_I<LANGUAGE>

This macro should invoke the compiler for the specified source language and build phase. It should expect source files as
inputs from the "%f" special variable and generate object files using the "%o" special variable.  It will be given one
source file at a time.

=item macro I<PHASE>_linkexe_I<LANGUAGE>

This macro should invoke the linker for the specified source language and build phase. It should expect object files
and/or libraries as inputs in the "%f" special variable, and generate an executable output file whose name is given by
the "%o" special variable.

=item macro I<PHASE>_link_static

This macro should run commands that convert the input files, all object files in the "%f" special variable, into an
archive or static library whose name is given by the "%o" special variable.

=item macro I<PHASE>_linklib_I<LANGUAGE>

This macro should invoke a linker for the specified source language and build phase. It should expect object files
and/or archives as inputs in the "%f" special variable, and generate a shared object or dynamic library whose name is
given by the "%o" special variable.

=item variable $(ROOT)

This variable is the relative name of the top of the project's source tree relative to the directory containing this
Tupfile.

=item variable $(INSTALL_STAGING)

This variable is the relative name of the installation staging directory with respect to the top of the build tree. It
must exist as a descendent of the build tree.

=back

=head1 COMMANDS

Instead of generating rules containing macros that must be defined elsewhere, this script can also generate commands
directly. The generated commands use variables for the various parts, and those variables are similar in name to variables
found in typical Makefiles except they're prefixed with the --phase name (separated by an undercore).

=over

=item Compiler commands

Compiler commands have the form "$(CXX) $(CPPFLAGS) $(CXXFLAGS) -o %o -c %f" where substrings "CXX" are replaced
by the upper-case name of the compiler ("CXX" for the C++ compiler, "C" for the C compiler, etc.). However, the variable
representing the name of the compiler executable is an exception to the rule: $(CXX) is the C++ compiler, and the others
are the language name followed by the letter "C". The "CPPFLAGS" variable appears only for C and C++ compilers and holds
command-line switches for the C preprocessor. All of these variables are prefixed by the phase name and an underscore if
a phase name was provided.

=back

=cut

use strict;
use FindBin;
use lib "$FindBin::Bin";
use TupScripts;

my($arg0) = $0 =~ m(([^/]+)$);
my $phase;                  # prefix for all tup variables, including the trailing "_"
my($output, $output2);      # name of output file ($output2 is when we generate both shared and static)
my $link;                   # whether to produce a library ('lib') or executable ('exe'), or neither ('none')
my $linkage = "both";       # whether to perform static linking ('static'), dynamic linking ('shared') or both ('both')
my $group;                  # optional output group
my @compiler_args;          # arguments to pass to the compiler
my @linker_args;            # arguments to pass to the linker
my @inputs;                 # names of the input files
my @order_inputs;           # additional order-only inputs
my $args_are_order_inputs;  # set by --begin-deps, cleared by --end-deps
my $install_dir = "none";   # directory in which to install, or empty to choose automatically
my $objects_bin;            # name of Tup bin for object files, excluding curly braces.
my $language;               # override default languages
my $emit_macros;            # emit macros instead of commands
my @extra_outputs;          # extra outputs for link commands
my $ncompiled = 0;	    # number of sources compiled
my @mapped_dirs;	    # empty, or the arguments of --map switch (absolute source dir and relative build dir)
my $command_flags = "";     # content of the ^-flags in tup commands
my $emit_compilation_db;    # emit rules to generate LLVM compilation database files; value is Tup group name

########################################################################################################################
sub parse_command_line {
    while (@_) {
        my $arg = shift @_;

        # --help
        if ($arg =~ /^(-h|--help|-\?)$/) {
            TupScripts::help;
            exit 0;
        }

        # --begin-deps | --end-deps
        if ($arg eq "--begin-deps") {
            die "$arg0: invalid \"$arg\" after previous \"$arg\" with no intervening \"--end-deps\"\n" if $args_are_order_inputs;
            $args_are_order_inputs = 1;
            next;
        }
        if ($arg eq "--end-deps") {
            die "$arg0: invalid \"$arg\" with no previous \"--begin-deps\"\n" unless $args_are_order_inputs;
            $args_are_order_inputs = 0;
            next;
        }

	# --compilation-database GROUP
	if ($arg eq '--compilation-database') {
	    die "$arg0: \"$arg\" expects an argument\n" unless @_;
	    $emit_compilation_db = shift @_;
	    next;
	}
	if ($arg =~ /^--compilation-database=(.*)/) {
	    $emit_compilation_db = $1;
	    next;
	}

        # --extra-output NAME | -x NAME
        if ($arg eq '--extra-output' || $arg eq '-x') {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            push @extra_outputs, shift @_;
            next;
        }
        if ($arg =~ /^(--extra-output=|-d)(.*)/) {
            push @extra_outputs, $2;
            next;
        }

        # --group=NAME
        if ($arg eq "--group") {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $group = shift @_;
            next;
        }
        if ($arg =~ /^--group=(.*)/) {
            $group = $1;
            next;
        }

        # --depend=NAME
        if ($arg eq '--depend') {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            push @order_inputs, shift @_;
            next;
        }
        if ($arg =~ /^--depend=(.*)/) {
            push @order_inputs, $1;
            next;
        }

        # --install
        if ($arg eq '--install') {
            $install_dir = "";  # choose directory later
            next;
        }
        if ($arg =~ /^--install=(.*)/) {
            $install_dir = $1;
            next;
        }

        # --language=LANG
        if ($arg eq '--language') {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $language = shift @_;
            next;
        }
        if ($arg =~ /^--language=(.*)/) {
            $language = $1;
            next;
        }

        # --link=(exe|lib|none)
        if ($arg eq '--link') {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $link = shift @_;
            next;
        }
        if ($arg =~ /^--link=(.*)/) {
            $link = $1;
            next;
        }

        # --linkage=(shared|static|both)
        if ($arg eq '--linkage') {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $linkage = shift @_;
            next;
        }
        if ($arg =~ /^--linkage=(.*)/) {
            $linkage = $1;
            next;
        }

        # --macro
        if ($arg eq '--macro') {
            $emit_macros = 1;
            next;
        }
        if ($arg eq '--no-macro') {
            $emit_macros = 0;
            next;
        }
               
        # -o NAME | --output=NAME
        if ($arg =~ /^(-o|--output)$/) {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $output = shift @_;
            next;
        }
        if ($arg =~ /^(-o|--output=)(.*)/) {
            $output = $2;
            next;
        }

	# --map=SRCDIR,BLDDIR
	if ($arg =~ /^--map=(.*)/) {
	    my @dirs = split(",", $1);
	    die "$arg0: \$arg\" expects two arguments separated by a comma\n" unless @dirs == 2;
	    @mapped_dirs = @dirs;
	    next;
	}

        # --objects=BIN
        if ($arg eq "--objects") {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $objects_bin = shift @_;
            next;
        }
        if ($arg =~ /^--objects=(.*)/) {
            $objects_bin = $1;
            next;
        }

        # --phase=NAME
        if ($arg eq "--phase") {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            $phase = shift @_;
            next;
        }
        if ($arg =~ /^--phase=(.*)/) {
            $phase = $1;
            next;
        }

        # Switches passed to the compiler
        if ($arg =~ /^-[DIU]$/) {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            push @compiler_args, $arg, shift @_;
            next;
        }
        if ($arg =~ /^-[DIU](.*)/) {
            push @compiler_args, $arg;
            next;
        }

        # Switches passed to the linker
        if ($arg =~ /^-[Ll]$/) {
            die "$arg0: \"$arg\" expects an argument\n" unless @_;
            push @linker_args, $arg, shift @_;
            next;
        }
        if ($arg =~ /^-[Ll](.*)/) {
            push @linker_args, $arg;
            next;
        }

        # Unknown
        if ($arg =~ /^-/) {
            die "$arg0: unknown switch: $arg\n";
        }

        # Input file
        if ($args_are_order_inputs) {
            push @order_inputs, $arg;
        } else {
            push @inputs, $arg;
        }
    }

    die "$arg0: missing \"--end-deps\" switch\n" if $args_are_order_inputs;
    die "$arg0: no inputs specified\n" unless @inputs;
    $install_dir = "auto" if $install_dir eq "";
    $phase .= "_" unless $phase eq "";
    die "$arg0: --group and --install are mutually exclusive\n" if $group && $install_dir ne "none";
    die "$arg0: object bin \"$objects_bin\" (from --objects) is malformed\n" unless $objects_bin =~ /^\w*$/;
    die "$arg0: invalid --link \"$link\"\n" unless $link =~ /^(exe|lib|python|none|)$/;
    die "$arg0: invalid --linkage \"$linkage\"\n" unless $linkage =~ /^(static|shared|both)$/;

    # Convert the compilation database name into a Tup group
    if ($emit_compilation_db ne "") {
	if ($emit_compilation_db =~ /<\w+>$/) {
	    # already a Tup group
	} elsif ($emit_compilation_db =~ /^(.*\/)?(\w+)$/) {
	    $emit_compilation_db = "$1<$2>";
	} else {
	    die "$arg0: compilation database is not a Tup group \"$emit_compilation_db\"\n";
	}
    }
}

########################################################################################################################
# Generate -fdebug-prefix-map switch
sub cxx_debug_prefix_map {
    my @switches;
    if (@mapped_dirs) {
	my $top_srcdir_abs = TupScripts::absolute_name($mapped_dirs[0]);
	my $cwd_rootrel = TupScripts::cwd_build_relative($mapped_dirs[1]);
	my $srcdir = TupScripts::canonical_name($top_srcdir_abs . "/" . $cwd_rootrel);
	my $blddir = Cwd::cwd();

	push @switches, "-fdebug-prefix-map=$blddir=$srcdir";
    }
    return @switches;
}

########################################################################################################################
# Given a list of languages (c, cxx) return the language that should be used for linking.
sub linker_language {
    return "d" if grep {$_ eq "d"} @_;
    return "cxx" if grep {$_ eq "c++"} @_;
    return $language || "c";
}

########################################################################################################################
# Fix the a group specification by adding angle brackets around the last component of the path.
sub make_group_name {
    my($input) = @_;
    return "" unless $input;
    my @parts = split "/", $input;
    $parts[-1] = "<" . $parts[-1] . ">" unless $parts[-1] =~ /^<.*>$/;
    return join "/", @parts;
}

########################################################################################################################
# Choose the $link and $linkage based on output file name.
sub choose_linking {
    if ($link eq "") {
        if ($output =~ /\.a$/) {
            $link = "lib";
            if ($linkage eq "") {
                $linkage = "static";
            } elsif ($linkage ne "static") {
                die "$arg0: invalid linkage \"$linkage\" for output \"$output\"\n";
            }
        } elsif ($output =~ /\.so$/) {
            $link = "lib";
            if ($linkage eq "") {
                $linkage = "shared";
            } elsif ($linkage ne "shared") {
                die "$arg0: invalid linkage \"$linkage\" for output \"$output\"\n";
            }
        } elsif ($language eq "moc" || grep {TupScripts::is_qt_ui($_) || TupScripts::is_qt_resource($_)} @inputs) {
            $link = "none";
        } elsif ($output =~ /^lib[^.]/) {
            $link = "lib";
        } else {
            $link = "exe";
        }
    }
}

########################################################################################################################
# Check that the $link mode is suitable for the input and output names, and choose output names and installation
# directories if none were specified.
sub choose_output_names {
    if ($link eq "exe") {
        for my $input (@inputs) {
            if (!TupScripts::is_source_code($input) && !TupScripts::is_library($input) && !TupScripts::is_object($input)) {
                die "$arg0: input for generating an executable is not source code, object, or library: $input\n";
            }
        }
        if ($output eq "") {
            my @non_libs = grep {!TupScripts::is_library($_)} @inputs;
            my $best_input = @non_libs ? $non_libs[0] : $inputs[0];
            $output = TupScripts::make_variable($best_input);
        }

        if ($linkage eq "both") {
            $output2 = $output . ".static";
        }

        $install_dir = "bin" if $install_dir eq "auto";

    } elsif ($link eq "lib") {
        for my $input (@inputs) {
            if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input) && !TupScripts::is_library($input)) {
                die "$arg0: input for generating a library is not source code, object, or library: $input\n";
            }
        }

        $output = TupScripts::make_variable($inputs[0]) unless $output;
        $output = $1 if $output =~ /^lib([^.].*)/; # remove leading "lib" for now, added later
        $output = $1 if $output =~ /^(.+)\.(a|so)$/;   # remove trailing ".a" or ".so" now, added later

        if ($linkage eq "shared") {
            $output = "lib" . $output . ".so";
        } elsif ($linkage eq "static") {
            $output = "lib" . $output . ".a";
        } else {
            ($output, $output2) = ("lib" . $output . ".so", "lib" . $output . ".a");
        }

        $install_dir = "lib" if $install_dir eq "auto";

    } elsif ($link eq 'python') {
        for my $input (@inputs) {
            if (!TupScripts::is_source_code($input) && !TupScripts::is_object($input) && !TupScripts::is_library($input)) {
                die "$arg0: input for generating a library is not source code, object, or library: $input\n";
            }
        }

        $output = TupScripts::make_variable($inputs[0]) unless $output;
        $output = $1 if $output =~ /^lib([^.].*)/; # remove leading "lib"
        $output = $1 if $output =~ /^(.+)\.so$/;   # remove trailing ".so" now, added later

        if ($linkage eq "shared") {
            $output = $output . ".so";
        } elsif ($linkage eq "static") {
	    die "$arg0: python API cannot be generated as a static library\n";
        } else {
	    die "$arg0: python API cannot be generated as a static library\n";
        }

        $install_dir = "lib" if $install_dir eq "auto";

    } elsif ($link eq "none") {
        my($generatingObjects, $generatingSource);
        for my $input (@inputs) {
            if (TupScripts::is_source_code($input)) {
                # okay, we're compiling source code to generate object files
                $generatingObjects = 1;
            } elsif (TupScripts::is_qt_ui($input)) {
                # okay, we're running Qt's "uic" tool to generate more *.h files
                $generatingSource = 1;
            } elsif (TupScripts::is_qt_resource($input)) {
                # okay, we're running Qt's "rcc" tool to generate more *.C files
                $generatingSource = 1;
            } else {
                die "$arg0: unrecognized compiler input file: $input\n";
            }
        }
        if ($generatingObjects && $output) {
            die "$arg0: --output is prohibited when generating object files\n";
        } elsif ($generatingSource && $output) {
            die "$arg0: --output is prohibited when generating source files\n";
        }

        if ($output eq "") {
            $output = TupScripts::make_variable($inputs[0]); # but we still need $output for various other things
        }
        if ($linkage eq "both") {
            $output2 = $output . ".static";
        }

    } else {
        die "$arg0: invalid --link mode: $link\n";
    }
}

########################################################################################################################
# Generate the compile rules.
sub generate_compile_rules {
    my ($sources) = @_;
    die unless ref($sources) eq 'HASH';

    for my $lang (keys %{$sources}) {
        next unless @{$sources->{$lang}};
        my $compile_macro = "${phase}compile_${lang}";       # name of macro if we're emitting macros
        my @rule_outputs;                                    # output names for the rule like %B.o, etc.
        my $uc_lang = uc($lang);                             # upper-case language name like CXX, C, D, etc. overridden below
        my $uc_compiler = TupScripts::compiler_exe($lang);   # upper-case compiler name like CXX, CC, etc.
        my @extra_compiler_args;                             # switches, flags, etc. appearing at end of command

        if ($lang eq "c++" || $lang eq "c") {
            $uc_lang = "CXX" if $uc_lang eq "C++";
            $compile_macro = "${phase}compile_" . lc($uc_compiler);
            push @rule_outputs, "${output}-%B.o";
            push @extra_compiler_args, cxx_debug_prefix_map(), '-o', '%o', '-c', '%f';
        } elsif ($lang eq 'd') {
            push @rule_outputs, TupScripts::make_variable($output) . '-%B.o';
            push @extra_compiler_args, '-of=%o', '-c', '%f';
        } elsif ($lang eq "moc") {
            push @rule_outputs, "moc_%B.cpp";
            push @extra_compiler_args, '-o', '%o', '%f';
        } elsif (TupScripts::is_source_code($sources->{$lang}[0])) {
            push @rule_outputs, "${output}-%B.o";
            push @extra_compiler_args, '-o', '%o', '%f';
        } elsif (TupScripts::is_qt_ui($sources->{$lang}[0])) {
            $uc_lang = "UIC";
            push @rule_outputs, "ui_%B.h";
            push @extra_compiler_args, '-o', '%o', '%f';
        } elsif (TupScripts::is_qt_resource($sources->{$lang}[0])) {
            $uc_lang = "RCC";
            push @rule_outputs, "qrc_%B.C";
            push @extra_compiler_args, '-o', '%o', '%f';
        } else {
            next; # not something to be compiled
        }

        # Inputs
	my $inputs_str = "foreach " . join(" ", @{$sources->{$lang}});
        $inputs_str .= " | " . join(" ", TupScripts::fix_bins(@order_inputs)) if @order_inputs;

        # Macro or command
	my $flags_str;
	my $command_str;
        if ($emit_macros) {
	    $command_str = "!${compile_macro} ";
	    $command_str .= " " . TupScripts::shell_escape($_) for @compiler_args;
	} else {
            $flags_str = "^${command_flags} ${phase}${uc_compiler} \%f^";
	    $command_str .= "\$(${phase}${uc_compiler})";
            $command_str .= " \$(${phase}CPPFLAGS)" if $lang eq "c++" || $lang eq "c";
            $command_str .= " \$(${phase}${uc_lang}FLAGS)";
            $command_str .= " " . TupScripts::shell_escape($_) for @compiler_args;
            $command_str .= " " . join(" ", @extra_compiler_args) if @extra_compiler_args;
	}

        # Outputs
	my $output_files_str = join(" ", @rule_outputs);
	my $output_group_str = ($group && $link eq "none" ? "${group}" : "");
	my $output_bin_str = "{${objects_bin}}";
	
	# Emit the compilation command
        print(": ", $inputs_str, 
              " |> ", $flags_str, " ", $command_str,
              " |> ", $output_files_str, " ", $output_group_str, " ", $output_bin_str, "\n");

	# Compilation database
	if ($emit_compilation_db ne "") {
	    print(": ", $inputs_str,
	          " |> ^${command_flags} compilation database \%f^",
		  " \$(compilation_database_record)",
		  " command=", TupScripts::shell_escape($command_str), " file=\%f >%o",
		  " |> ", join(" ", map {"$_.json"} @rule_outputs), " ", $emit_compilation_db, "\n");
	}

        $ncompiled += @{$sources->{$lang}};
    }
}

########################################################################################################################
sub generate_link_rules {
    my($linkage, $output, $sources) = @_;
    die unless ref($sources) eq 'HASH';

    my $lang = linker_language(keys %{$sources});

    # Get the list of linker inputs
    my @linker_inputs;
    push @linker_inputs, "{${objects_bin}}" if $ncompiled > 0;
    push @linker_inputs, TupScripts::fix_groups_bins(@{$sources->{object}});

    # Get the various parts of the eventual macro or command
    my $link_macro;
    my @compiler_args;
    if ($link eq "exe") {
	$link_macro = "${phase}linkexe_" . linker_language(keys %{$sources});
	if ($lang eq 'd') {
	    push @compiler_args, '-of=%o', TupScripts::tup_input_variable(@linker_inputs);
	} else {
	    push @compiler_args, '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
	}
    } elsif ($link eq "lib" || $link eq "python") {
	if ($linkage eq "static") {
            $link_macro = "${phase}link_static";
	} else {
	    die unless $linkage eq "shared";
            $link_macro = "${phase}linklib_" . linker_language(keys %{$sources});
            if ($lang eq 'cxx' || $lang eq 'c') {
                push @compiler_args, '-shared', '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
            } elsif ($lang eq 'd') {
                push @compiler_args, '-lib', '-of=%o', TupScripts::tup_input_variable(@linker_inputs);
            } else {
                push @compiler_args, '-o', '%o', TupScripts::tup_input_variable(@linker_inputs);
            }
	}
    } else {
	die "$arg0: internal logic error (link=$link)\n";
    }

    # Library names specified as files, like "../../libfoo.so" need to be passed to the linker as "-L../.. -lfoo" in order
    # to work properly with rpath after being installed, but they need to be listed as "../../libfoo.so" in the rule's
    # order-only dependencies so that Tup knows about them. Furthermore, the directory names should be absolute so that
    # the resulting executable can be invoked from any working directory.
    my @linker_order_inputs;
    for my $l (@{$sources->{library}}) {
	# Normalize the library name by making sure it ends with the proper file extension for the $linkage mode
	my($lib) = $l;
	$lib = $1 if $lib =~ /^((.*\/)?lib[^.].*?)(\.(a|so))?$/;
	$lib .= ".a" if $linkage eq "static";
	$lib .= ".so" if $linkage eq "shared";

	# Get a library base name like "foo" if the input is "/some/libdir/libfoo.so"
	my $lib_basename = TupScripts::base_name($lib);
	my $lib_name = $lib_basename;
	$lib_name = $1 if $lib_name =~ /^lib([^.].*)/;
	$lib_name = $1 if $lib_name =~ /^(.+)\.(a|so)$/;

	#my($lib_dirname) = TupScripts::canonical_name(TupScripts::absolute_name(TupScripts::directory_name($lib)));
	my($lib_dirname) = TupScripts::directory_name($lib);
	push @linker_order_inputs, $lib unless $lib =~ /^\//; # absolute names are not managed by Tup
	if ($lang eq 'cxx' || $lang eq 'c') {
	    unshift @linker_args, "-L$lib_dirname", "-Wl,-rpath,$lib_dirname", "-l$lib_name";
	} elsif ($lang eq 'd') {
	    unshift @linker_args, $lib, "-L=-rpath", "-L=$lib_dirname";
	} else {
	    unshift @linker_args, $lib;
	}
    }

    # Rule inputs
    print ": ", join(" ", @linker_inputs);
    print " | ", join(" ", @linker_order_inputs) if @linker_order_inputs;

    # The command or macro
    print " |>";
    if ($emit_macros) {
	print " !${link_macro}";
	print " ", join(" ", @linker_args) if @linker_args;
    } elsif ($link eq "lib" && $linkage eq "static") {
	print " ^${command_flags} ${phase}LINK \%o^ ar rcs %o %f";
    } else {
	my $uc_lang = uc($lang);
	my $uc_compiler = TupScripts::compiler_exe($lang);
	print " ^${command_flags} ${phase}LINK \%o^";
	print " \$(${phase}${uc_compiler}) \$(${phase}${uc_lang}FLAGS)";
	print " ", join(" ", @compiler_args) if @compiler_args;
	print " ", join(" ", @linker_args) if @linker_args;
	print ' $(' . $phase . "LDFLAGS_" . uc($linkage) . ")";
    }

    # Output
    print " |> ${output}";
    print " | ", join(" ", @extra_outputs) if @extra_outputs;
    print " ${group}" if $group;
    print " \$(ROOT)/\$(INSTALL_STAGING)/$install_dir/<staging>" if $install_dir ne "none";
    print "\n";
}

########################################################################################################################

parse_command_line @ARGV;
$group = make_group_name $group;

# If any header files are specified in the inputs, move them to the order-only inputs instead because headers are not
# normally compiled directly.
if ($language ne "moc") {
    push @order_inputs, grep {TupScripts::language("", $_) eq "header"} @inputs;
    @inputs =           grep {TupScripts::language("", $_) ne "header"} @inputs;
}

choose_linking;
choose_output_names;

my($var) = TupScripts::make_variable($output);
$objects_bin = "${var}_OBJECTS" unless $objects_bin;

# Split the inputs into arrays based on their type.
my %sources = TupScripts::by_language($language, @inputs);

generate_compile_rules(\%sources);
if ($link ne "none") {
    if ($linkage eq "shared" || $linkage eq "static") {
	generate_link_rules($linkage, $output, \%sources);
    } else {
	generate_link_rules("shared", $output,  \%sources);
	generate_link_rules("static", $output2, \%sources);
    }
}
